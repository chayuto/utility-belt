# **Engineering a Robust TypeScript Parser for Ruby Hash Serialization: A Comprehensive Analysis of Syntactic Morphology, Edge Cases, and Interoperability Protocols**

## **1\. Executive Summary and Architectural Context**

The interoperability between Ruby, a dynamic language renowned for its expressive syntax, and the JavaScript ecosystem, dominated by the strict Object Notation (JSON) standard, presents a distinct class of engineering challenges. This report provides an exhaustive analysis of the requirements for developing a TypeScript library capable of parsing Ruby Hash string representations—specifically those generated by the Object\#inspect method—and transforming them into valid JSON.  
Unlike standard serialization protocols such as JSON.generate, which enforce strict schema adherence, the inspect output is designed for developer observability. It reflects the internal state of the Ruby Virtual Machine (MRI) and encompasses a history of syntactic evolution spanning from Ruby 1.8 to the current 3.x series. The input data, often scraped from console logs or debugging streams, is characterized by irregular grammars, varying key-value delimiters (=\> vs. :), and Ruby-specific scalar types that lack direct equivalents in the JSON specification.  
This analysis establishes that a simple regular expression-based approach is mathematically insufficient due to the recursive, nested nature of the data structures and the context-sensitive lexical rules of Ruby. Consequently, this report advocates for a formal Parsing Expression Grammar (PEG) implementation. We will dissect the morphological structure of Ruby hashes, the encoding nuances of string literals (including hex, octal, and control character escapes), and the serialization behaviors of complex objects like BigDecimal, Time, and Struct. The findings provide a definitive blueprint for an industrial-grade TypeScript parsing library, ruby-hash-parser, ensuring high fidelity in data recovery and type coercion.

## **2\. The Morphology of Ruby Hash Syntax: A Historical and Syntactic Analysis**

To engineer a parser of sufficient robustness, one must first deconstruct the input language. Ruby’s Hash syntax is not a static target; it is a layered accumulation of syntactic sugar and interpreter directives that have evolved over two decades. A robust parser must possess the capability to recognize, normalize, and transform all valid forms, which often co-exist within a single data structure due to legacy code retention and developer preference.

### **2.1. The Evolution of Associative Array Delimiters**

The most visually distinct feature of a Ruby Hash is its method of associating keys with values. While JSON enforces a rigid key: value structure where keys must be double-quoted strings, Ruby offers a permissive environment that significantly complicates the tokenization phase.  
**The "Hash Rocket" (=\>) Syntax** Introduced in the earliest versions of Ruby and serving as the dominant paradigm through the 1.8 era, the "hash rocket" syntax explicitly separates keys and values using the \=\> operator. This syntax is universal in the Ruby domain; it supports keys of any data type—Symbols, Strings, Integers, Floats, Arrays, and even other Hashes.

* **Syntactic Structure:** {:name \=\> "Alice", "age" \=\> 30, 1 \=\> "id"}  
* **Parser Implication:** The parser must recognize \=\> as a distinct high-precedence token separating the Left-Hand Side (LHS) expression from the Right-Hand Side (RHS) expression. Unlike JSON, where the LHS is guaranteed to be a string literal, the LHS in a hash rocket pair is an *expression* that must be evaluated or parsed recursively. For instance, KeyExpression could be a static symbol (:key) or a method call that was inspected (\#\<Object:...\>), requiring the grammar to support heterogeneous key types.

**The "JSON-Style" Symbol Syntax** Introduced in Ruby 1.9 to align closer with JavaScript object literals and reduce character count, this syntax places the colon *after* the key (key: value). However, this syntax imposes a critical semantic constraint: the key *must* be a Symbol.

* **Syntactic Structure:** {name: "Alice", age: 30}  
* **Parser Implication:** This introduces ambiguity in tokenization. When the parser encounters an identifier followed immediately by a colon (e.g., name:), it must interpret the token name as a Symbol (:name), effectively performing a type coercion during the AST generation phase. This differs syntactically from the hash rocket, where the colon precedes the symbol identifier (:name). The parser must define a lookahead rule to distinguish between a label (key:) and a symbol value that might appear elsewhere.

**Mixed Syntax Environments** Ruby’s parser is permissive, allowing the intermingling of these styles within a single Hash structure. This is frequently observed in applications undergoing incremental upgrades or in scenarios where specific keys (such as Integers or Strings containing whitespace) necessitate the hash rocket syntax while others utilize the modern 1.9 syntax.

* **Input Example:** {name: "Alice", :status \=\> "active", "meta-data" \=\> {id: 1}}  
* **Architectural Requirement:** The grammar cannot enforce a global style per document. It must define a Pair production rule that accepts an OrderedChoice of RocketPair or JsonStylePair. The TypeScript library must verify that such mixing is handled gracefully, normalizing the output to a consistent JSON format (typically string keys).

### **2.2. Implicit Construction and Argument Coercion**

A significant deviation from JSON structure occurs in Ruby's handling of method arguments. If a Hash is the last argument in a method call, the enclosing braces {} are optional. While inspect typically restores these braces during output, console logs capturing argument lists (e.g., p \*args) may expose brace-less key-value sequences.

* **Input Example:** key: "value", other: 123  
* **Parser Implication:** The root production rule of the grammar (Start) must accept an optional enclosing brace structure. If braces are absent, the parser should treat the entire input string as a PairList, provided the lexical structure holds valid pairs. This effectively mimics the Hash constructor behavior described in the documentation, which builds a hash from an even-numbered list of arguments.

### **2.3. The Ambiguity of "Symbol" Representation**

Symbols are a Ruby-specific primitive representing immutable, interned strings. They are central to Ruby Hashes but entirely absent in the JSON specification. The inspect output for symbols varies significantly based on the symbol's content and the Ruby version, creating a complex matrix of parsing rules.

| Syntax Variation | Context | Parser Strategy |
| :---- | :---- | :---- |
| :simple | Standard symbol identifier. | Tokenize as SymbolLiteral, strip :, coerce to String. |
| simple: | JSON-style key (1.9+). | Tokenize as Label, coerce to String. |
| :'complex key' | Symbol containing spaces/hyphens. | Tokenize as quoted string, strip :' and '. |
| :"complex key" | Symbol allowing interpolation. | Tokenize as quoted string, handle escapes \\". |

**Citation Support:**.  
The parser must handle quoting mechanisms for symbols identical to those for strings. The tokenization of a symbol must account for the optional quoting and the position of the colon. Furthermore, the library must implement a strategy for "interning" these keys if the TypeScript environment requires object consistency, although simply converting them to JSON strings is the standard interoperability path.

## **3\. Deep Analysis of Scalar Data Types and Escaping Protocols**

The fidelity of the TypeScript library depends on its ability to correctly interpret the scalar data types produced by inspect. Unlike to\_json, which attempts to serialize data into a transport format, inspect describes the object's internal state for a developer. This distinction is critical because inspect produces strings that are valid Ruby code but often invalid JSON.

### **3.1. String Literals: The Complexity of Quotes and Escapes**

Ruby strings are significantly more complex than JSON strings. A TypeScript parser must implement a full Ruby string state machine to correctly handle the content, distinguishing between single-quoted and double-quoted literals.  
**Single vs. Double Quotes** Ruby inspect defaults to double quotes ("...") for most strings but may use single quotes ('...') or percent-string notation (%q{...}) in specific contexts or manual formatting.

* **Double Quotes:** Support interpolation (though inspect resolves this, the output is static) and a wide range of escape sequences (\\n, \\t, \\uXXXX, \\C-x, \\M-x).  
* **Single Quotes:** Support minimal escaping. Only \\' (literal single quote) and \\\\ (literal backslash) are processed. Crucially, a sequence like \\n in a single-quoted string is treated as two distinct characters: a backslash and an 'n'. The parser must recognize the delimiter to apply the correct unescaping logic.

**Escape Sequence Divergence and Binary Data** A critical failure point for regex-based parsers is the handling of escape sequences. Ruby supports octal escapes (\\377) and hex escapes (\\xFF) which are not valid in standard JSON (which requires \\u00FF).

* **Octal/Hex Handling:** An input string like "\\xFF" represents a byte with value 255\. In JSON, strings must be UTF-8. If \\xFF represents a valid UTF-8 code unit (rare in isolation), it must be transcoded. If it represents raw binary data, the parser faces a dilemma.  
* **Binary Data Strategy:** Ruby strings can contain arbitrary bytes (e.g., File.read("image.jpg").inspect produces "\\xFF\\xD8..."). Since JSON cannot natively represent binary data, the TypeScript library should define a binaryStrategy option:  
  1. *Base64 Encode:* Convert raw byte sequences to a Base64 string.  
  2. *Array of Integers:* Convert to \[255, 216,...\].  
  3. *Replacement Character:* Replace invalid UTF-8 sequences with \\uFFFD.  
* **Reference:**.

**Control Character Escapes** Ruby inspect makes liberal use of shorthand control characters for readability, which are strictly forbidden in JSON:

* \\a (Bell/Alert, ASCII 0x07)  
* \\e (Escape, ASCII 0x1B)  
* \\v (Vertical Tab, ASCII 0x0B)  
* \\f (Form Feed, ASCII 0x0C)

**Table 1: Ruby to JSON Escape Sequence Mapping**

| Ruby Escape | Description | JSON Equivalent (TypeScript) | Note |
| :---- | :---- | :---- | :---- |
| \\a | Bell | \\u0007 | Not supported in JSON; requires Unicode escape. |
| \\e | Escape | \\u001B | Common in ANSI color codes in logs. |
| \\v | Vertical Tab | \\u000B | Whitespace handling variance. |
| \\s | Space | (Space) | Explicit space escape. |
| \\C-x | Control-x | String.fromCharCode(x.charCodeAt(0) % 32\) | Emacs-style control sequences. |
| \\M-x | Meta-x | \`String.fromCharCode(x.charCodeAt(0) | 0x80)\` |

**Citation Support:**.  
The library's tokenizer must explicitly map these Ruby-specific control escapes to their Unicode hexadecimal equivalents (\\uXXXX) during the string parsing phase to ensure the resulting JSON string is valid.

### **3.2. Numeric Types and Non-Finite Values**

JSON standards (RFC 8259\) restrict numbers to finite values. Ruby, however, supports a richer numeric system that inspect faithfully reports, creating significant interoperability gaps.  
**Integers and Underscores** Ruby allows underscores for readability in numbers (e.g., 1\_000\_000), which is syntactically invalid in JSON.

* **Input:** {count: 1\_000\_000}  
* **Parser Implication:** The lexer for numeric tokens must be capable of consuming and discarding underscores within digit sequences. It must also handle binary (0b101), octal (0755), and hexadecimal (0xFF) literals, converting them to decimal integers for the JSON output.

**Infinity and NaN** Floating-point calculations often result in Float::INFINITY or Float::NAN.

* **Ruby Inspect Output:** {val: Infinity, other: NaN, neg: \-Infinity}  
* **JSON Limitation:** Infinity and NaN are treated as identifiers, not numbers, in JSON.  
* **Resolution Strategy:** The library must offer configuration options for these edge cases, as behaviors vary across JSON parsers.  
  1. *Null Coercion:* (Standard JSON behavior) Infinity \-\> null.  
  2. *String Coercion:* Infinity \-\> "Infinity".  
  3. *Extended Mode:* Emit raw Infinity literals if the target consumer supports JSON5.

**BigDecimal Serialization** Ruby's BigDecimal is crucial for financial calculations where floating-point precision is unacceptable. Its inspect output is distinct and verbose.

* **Output Format:** \#\<BigDecimal:7f8c,'0.12E2',9(18)\>.  
* **Analysis:** This is not a hash literal; it is an object inspection. The parser must recognize the \#\<ClassName...\> pattern. For BigDecimal, the semantic value is embedded in the string (e.g., '0.12E2').  
* **Conversion Logic:** The library should implement a specific grammar rule for BigDecimal that extracts the numeric string (0.12E2). This should be returned as a string in the JSON output to preserve precision, as converting to a JavaScript number would reintroduce floating-point errors.

### **3.3. Singleton Literals: True, False, Nil**

Ruby uses nil to represent the absence of a value, whereas JavaScript/JSON uses null.

* **Input:** {val: nil}  
* **Output:** {"val": null}  
* **Tokenization:** The lexer must recognize nil as a keyword and emit a NULL token for the AST construction. true and false map 1:1, but the parser must ensure they are treated as boolean literals and not identifiers.

## **4\. Complex Object Structures and Recursive Serialization**

The inspect method is recursive. When it encounters complex objects or nested collections, it calls inspect on them. However, it also includes safeguards against infinite recursion and often outputs class-specific formats that require specialized parsing logic.

### **4.1. Recursive Data Structures and Cycle Detection**

Ruby Hash objects can contain references to themselves, creating cyclic graphs.

* **Code Example:** h \= {}; h\[:a\] \= h; p h  
* **Inspect Output:** {:a=\>{...}}.  
* **Deep Research Insight:** The inspect method detects recursion and replaces the cyclic reference with \[...\] (for Arrays) or {...} (for Hashes).  
* **Parser Challenge:** If the parser encounters {:a=\>{...}}, interpreting {...} literally is meaningless. It represents a cycle where the reference pointer is lost in the string representation.  
* **Library Behavior:** The TypeScript library cannot reconstruct the cycle because the input string lacks the reference address (it doesn't specify *which* object it points to, only that it recurses). The library should parse {...} as a specific sentinel value, such as the string "", or optionally throw a distinct CyclicDataError.

### **4.2. Object Identity and \#\<Object\> Notation**

Any Ruby object that does not override inspect generally outputs a string containing the class name, memory address, and instance variables.

* **Input:** {user: \#\<User:0x00007f9 @name="Dave" @age=30\>}.  
* **Analysis:** This syntax acts like a generic object literal but is wrapped in angle brackets and prefixed with \#. It typically lists instance variables (@ivar=val).  
* **Parsing Strategy:**  
  1. *Strict Parsing:* A grammar rule ObjectInspection can be defined to match \#\<Identifier:Address (InstanceVar)\*\>.  
  2. *Transformation:* The parser can attempt to extract the instance variables into a JSON object: { "user": { "\_\_class": "User", "name": "Dave", "age": 30 } }. This requires recognizing the @ sigil and parsing the subsequent value using the standard value parser (recursion).  
  3. *Fallback:* If parsing fails (e.g., custom to\_s output inside the brackets), the entire sequence should be captured as a string.

### **4.3. The Set Class**

Ruby's Set library creates collections of unique values.

* **Inspect Output:** \#\<Set: {1, 2, 3}\>.  
* **JSON Equivalence:** JSON does not possess a Set type; it relies on Arrays.  
* **Transformation:** The library must explicitly recognize the Set wrapper syntax. The grammar should strip the \#\<Set: prefix and the trailing \>, then parse the internal {1, 2, 3} as a collection. This collection should be emitted as a JSON Array \`\`.

### **4.4. Time, Date, and Range Objects**

**Time and Date** Time objects often inspect as plain strings in many contexts but may lack quotes depending on the printer used (e.g., pp vs puts).

* **Output:** 2023-12-13 12:00:00 \+0000.  
* **Ambiguity:** Without quotes, this sequence (Year-Month-Day...) acts as a series of subtraction and addition operations if parsed as a standard expression.  
* **Parser Rule:** The grammar must define a Timestamp literal rule that matches the ISO-like pattern YYYY-MM-DD HH:MM:SS. Upon matching, this should be wrapped in quotes to form a valid JSON string.

**Ranges** Ruby Ranges (1..10 or 1...10) are not supported in JSON.

* **Inspect Output:** 1..10.  
* **Serialization:** Attempting to parse 1..10 as JSON fails.  
* **Transformation Strategy:** The library should convert ranges into a standardized object representation or a string.  
  * *Object:* { "begin": 1, "end": 10, "exclude\_end": false }  
  * *String:* "1..10"  
  * *Array Expansion:* \[1, 2,..., 10\] (Dangerous for large ranges).  
  * *Recommendation:* The parser should default to the Object representation to preserve the semantic meaning of inclusive (..) vs exclusive (...) bounds.

## **5\. Parsing Theory and Grammar Specification**

To solve this problem deterministically, we must define the Parsing Expression Grammar (PEG) that the TypeScript library will implement. This approach supersedes Regular Expressions, which are mathematically incapable of handling the arbitrary nesting depth of Hash structures ({a: {b:...}}).

### **5.1. Why PEG (Parsing Expression Grammar)?**

Regular expressions (Type 3 in the Chomsky hierarchy) cannot count. They cannot match balanced delimiters (nested braces) reliably. Ruby Hashes are Context-Free Languages (Type 2). While a Context-Free Grammar (CFG) would suffice, PEGs are generally preferred for computer languages because they are unambiguous—the "Ordered Choice" operator (/) ensures that the first matching rule wins, eliminating the ambiguity inherent in CFGs.  
For this library, **Peggy** (formerly PEG.js) is the selected tool. It generates highly optimized JavaScript/TypeScript parsers from a formal grammar definition.

### **5.2. Formal Grammar Definitions (Pseudocode/Peggy Format)**

The following grammar section defines the core rules required to handle the syntactic variations discussed above.  
`// Root Rule: Handles optional braces for implicit hashes`  
`Start`  
  `= Hash`  
  `/ ImplicitHash`

`// Whitespace handling (crucial for formatting resilience)`  
`_ "whitespace"`  
  `= [ \t\n\r]*`

`// The core Hash structure`  
`Hash`  
  `= "{" _ Pairs? _ "}"`

`// Implicit hash (arguments list without braces)`  
`ImplicitHash`  
  `= Head:Pair Tail:(_ "," _ Pair)* {`  
      `return)];`  
  `}`

`Pairs`  
  `= Head:Pair Tail:(_ "," _ Pair)* {`  
      `return)];`  
  `}`

`// The Ordered Choice of Key styles`  
`Pair`  
  `= RocketPair`  
  `/ JsonStylePair`

`// 1.8 Style: :key => value or "key" => value`  
`RocketPair`  
  `= Key:KeyExpression _ "=>" _ Val:ValueExpression {`  
      `return { key: Key, value: Val };`  
  `}`

`// 1.9+ Style: key: value`  
`JsonStylePair`  
  `= Key:IdentifierKey _ ":" _ Val:ValueExpression {`  
      `return { key: Key, value: Val };`  
  `}`

`// Keys can be almost anything in Ruby`  
`KeyExpression`  
  `= Symbol`

`| StringLiteral`  
`| NumberLiteral`  
`| Array`  
`| Hash // Nested keys!`

`// Valid values`  
`ValueExpression`  
  `= Hash`

`| Array`  
`| StringLiteral`  
`| Symbol`  
`| NumberLiteral`  
`| Primitive     // true, false, nil`  
`| ObjectInspect // #<Object...>`  
`| RangeLiteral  // 1..10`

`// Complex Types`  
`Symbol`  
  `= ":" id:[a-zA-Z_][a-zA-Z0-9_]* { return id.join(""); } // Simple :sym`

`| ":" str:StringLiteral { return str; }                 // Quoted :"sym"`

`ObjectInspect`  
  `= "#<" content:(!">".)* ">" {`  
      `return { type: "Object", raw: content.flat().join("") };`  
  `}`

### **5.3. AST Transformation and Key Coercion**

The PEG parser generates an Abstract Syntax Tree (AST). The library must include a Transformer pass to convert this AST into a JavaScript object. This step is where the type mismatches between Ruby and JSON are resolved.  
**Key Coercion Rules:**

1. **Symbol Keys:** Convert directly to string. :status (Symbol) → "status" (String).  
2. **Numeric Keys:** Convert to string representation. 1 (Integer) → "1" (String). JSON keys must be strings.  
3. **Complex Keys:** If a Ruby hash uses an Array or another Hash as a key (e.g., { \=\> "value" }), the library must stringify the key.  
   * *Strategy:* JSON.stringify(keyAST) → "". This ensures uniqueness and validity in the output JSON object.

## **6\. Implementation Strategy: The ruby-hash-parser Library**

This section outlines the API design and implementation details for the TypeScript library.

### **6.1. API Design**

The library should expose a synchronous parsing API with configuration options to handle the "lenient" nature of the parsing required for console logs.  
`interface ParserOptions {`  
  `/**`  
   `* Strategy for handling Ruby Symbols.`  
   `* 'string': Convert :sym to "sym"`  
   `* 'preserve': Keep as specific Symbol object (not valid JSON)`  
   `*/`  
  `symbolHandler?: 'string' | 'preserve';`

  `/**`  
   `* Handling of Infinity/NaN.`  
   `* 'null': Convert to null (Standard JSON)`  
   `* 'string': Convert to "Infinity"`  
   `* 'literal': Preserve identifier (JSON5 compatible)`  
   `*/`  
  `nonFiniteNumbers?: 'null' | 'string' | 'literal';`

  `/**`  
   `* Handling of #<Object...> inspections.`  
   `* 'string': Return the raw string "#<...>"`  
   `* 'object': Attempt to parse instance variables into an object`  
   `*/`  
  `objectBehavior?: 'string' | 'object';`

  `/**`  
   `* If true, allows "key: val" syntax without enclosing braces.`  
   `*/`  
  `allowImplicitHash?: boolean;`  
`}`

`export function parse(rubyString: string, options?: ParserOptions): any;`

### **6.2. Handling Ruby's "Quirks" in Production**

**The Hash.new Default Value:** Ruby Hash.inspect does *not* output the default value set during initialization. A hash created via Hash.new("default") inspects simply as {}.

* *Constraint:* The library cannot recover the default value from the inspect string. This data is lost. The output JSON will simply be an empty object {}.

**Source Code vs. Runtime Output:** If the user inputs user \= {name: name}, and name is a variable, inspect will have already resolved it to {:name \=\> "Alice"}. The library assumes it is parsing the *output* of an execution, not static source code. If raw source code with variables is passed, the PEG parser will fail at the variable identifier, as it expects a value literal. This is intended behavior; the library is a *data parser*, not a *language interpreter*.

### **6.3. Testing Verification Strategy**

To ensure reliability, the test suite must define a "Golden Master" verification process.

1. **Generation:** A Ruby script generates inspect outputs for thousands of permutations of Hash structures (nested, mixed syntax, special characters, binary data) across multiple Ruby versions (1.8.7, 2.7, 3.2).  
2. **Verification:** The TypeScript library parses these outputs.  
3. **Round-Trip:** The resulting JSON is compared against a JSON.generate output from Ruby (where possible) or manual assertions for non-standard types.

## **7\. Security and Performance Considerations**

### **7.1. The Danger of eval()**

A naive implementation might attempt to use JavaScript's eval() to parse the "JSON-like" parts of the string. This is catastrophic.

* **Security Risk:** Ruby syntax allows arbitrary expressions. While inspect output is generally static, malicious input could craft a string that looks like a Hash but executes JS code if eval is used.  
* **Syntax Incompatibility:** Ruby symbols (:key) are syntax errors in JavaScript.  
* **Conclusion:** The PEG parser acts as a sandbox. It tokenizes only valid data structures and executes no code, eliminating code injection risks.

### **7.2. Denial of Service (DoS) via Nesting**

Deeply nested structures can cause stack overflow errors in recursive descent parsers.

* **Mitigation:** The grammar should enforce a maxDepth limit (e.g., 500 levels). If the nesting exceeds this, the parser should throw a generic RecursionLimitExceeded error rather than crashing the Node.js process.

### **7.3. Performance Optimization**

Parsing large console logs (megabytes of data) requires efficient memory management.

* **String Interning:** The grammar can utilize string interning for repeated keys to reduce memory footprint, although the final JSON object generation will likely duplicate strings.  
* **Streaming:** While Peggy generates a parser that requires the full string, for massive logs, a streaming tokenizer (Lexer) feeding a state machine might be preferred. However, for the defined use case (console output), the PEG approach offers the best trade-off between performance and development complexity.

## **8\. Conclusion**

Converting Ruby Hash strings to JSON is a complex translation task between two Context-Free Grammars with significant impedance mismatches. The Ruby grammar is permissive, supporting mixed delimiters, symbol types, and non-finite numbers, while JSON is rigid.  
The research indicates that a comprehensive solution must explicitly handle the inspect output of Ruby's core classes (Time, BigDecimal, Set, Struct) to be practically useful. A parser that fails on \#\<Date...\> or Infinity will break in real-world Rails debugging scenarios. By implementing a grammar that supersets JSON to include Ruby's primitives and transforming the AST with strict coercion rules for keys, the ruby-hash-parser library can provide a reliable, industrial-grade bridge for developers inspecting Ruby state in TypeScript environments.  
This report confirms that regex solutions are fundamentally inadequate and establishes the formal grammar definition as the required path for a reliable solution.

#### **Works cited**

1\. class Hash \- RDoc Documentation \- Ruby-Doc.org, https://ruby-doc.org/core/Hash.html 2\. Ruby Hashes \- A Detailed Guide \- Launch School, https://launchschool.com/books/ruby/read/hashes 3\. hash from string | Ruby \- Coding Forums, https://www.thecodingforums.com/threads/hash-from-string.852056/ 4\. Pattern Matching in Ruby with Regex Look-arounds | by Stacey McKnight | Medium, https://staceymck.medium.com/pattern-matching-in-ruby-with-regex-look-arounds-7ba983ce609 5\. Ruby Hash Syntax: Hashrocket vs JSON-Style \- { always: 'coding' }, https://alwayscoding.ca/momentos/2012/06/15/ruby-hash-syntax-hashrocket-vs-json-style/ 6\. Almost all of the issues mentioned in this post were during 1.8 \-\> 1.9 transitio... | Hacker News, https://news.ycombinator.com/item?id=39015757 7\. What are the benefits of the new hash syntax in Ruby 1.9? \- Stack Overflow, https://stackoverflow.com/questions/11412242/what-are-the-benefits-of-the-new-hash-syntax-in-ruby-1-9 8\. 13 Ways of Looking at a Ruby Symbol \- Random Hacks, https://www.randomhacks.net/2007/01/20/13-ways-of-looking-at-a-ruby-symbol/ 9\. The symbol in Ruby \- Explanation \- DEV Community, https://dev.to/rafalpiekara/the-symbol-in-ruby-explanation-3m14 10\. Ruby JSON parse changes Hash keys \- Stack Overflow, https://stackoverflow.com/questions/7543779/ruby-json-parse-changes-hash-keys 11\. Escaping characters in Ruby \- AppSignal Blog, https://blog.appsignal.com/2016/12/21/ruby-magic-escaping-in-ruby.html 12\. How to Escape single and double quotes in a string in Ruby? \- GeeksforGeeks, https://www.geeksforgeeks.org/ruby/how-to-escape-single-and-double-quotes-in-a-string-in-ruby/ 13\. Escape Sequences (How To) | Ruby Basics \- Team Treehouse, https://teamtreehouse.com/library/ruby-basics-2/escape-sequences 14\. Escaping metacharacters \- Understanding Ruby Regexp \- learnbyexample, https://learnbyexample.github.io/Ruby\_Regexp/escaping-metacharacters.html 15\. Why does Ruby convert integer to octal-escaped string instead of hex-escaped one?, https://stackoverflow.com/questions/28721709/why-does-ruby-convert-integer-to-octal-escaped-string-instead-of-hex-escaped-one 16\. To Hex and Back (With Ruby) \- AnthonyLewis.com, https://anthonylewis.com/2011/02/09/to-hex-and-back-with-ruby/ 17\. Reading Binary Data in Ruby \- Rails Insights, https://railsinsights.com/blog/reading-binary-data-in-ruby 18\. literals \- Documentation for Ruby 2.4.0, https://docs.ruby-lang.org/en/2.4.0/syntax/literals\_rdoc.html 19\. Where can I find string escape sequences in the Ruby documentation? \- Stack Overflow, https://stackoverflow.com/questions/19743964/where-can-i-find-string-escape-sequences-in-the-ruby-documentation 20\. JSON Parsing and NaN and Infinity (Java in General forum at Coderanch), https://coderanch.com/t/528867/java/JSON-Parsing-NaN-Infinity 21\. JSON left out Infinity and NaN; JSON status in ECMAScript? \- Stack Overflow, https://stackoverflow.com/questions/1423081/json-left-out-infinity-and-nan-json-status-in-ecmascript 22\. How to convert a number to Binary in Ruby? \- GeeksforGeeks, https://www.geeksforgeeks.org/ruby/how-to-convert-a-number-to-binary-in-ruby/ 23\. Is there a way to force ruby to output results in binary \- Stack Overflow, https://stackoverflow.com/questions/37956842/is-there-a-way-to-force-ruby-to-output-results-in-binary 24\. Interoperability of Infinity, \-Infinity and NaN in JSON ecosystem? \- Stack Overflow, https://stackoverflow.com/questions/77458244/interoperability-of-infinity-infinity-and-nan-in-json-ecosystem 25\. Ruby | BigDecimal class inspect value \- GeeksforGeeks, https://www.geeksforgeeks.org/ruby/ruby-bigdecimal-class-inspect-value/ 26\. How to parse ruby BigDecimal inspect? \- Stack Overflow, https://stackoverflow.com/questions/31178626/how-to-parse-ruby-bigdecimal-inspect 27\. Class: BigDecimal (Ruby 2.5.1) \- Ruby-Doc.org, https://ruby-doc.org/stdlib-2.5.1/libdoc/bigdecimal/rdoc/BigDecimal.html 28\. How to pretty-print decimal format \- ruby \- Stack Overflow, https://stackoverflow.com/questions/43506799/how-to-pretty-print-decimal-format 29\. Ruby to JSON Converter \- Free Online Tool, https://jsontotable.org/ruby-to-json 30\. The Evolution of Keyword Arguments in Ruby: From 1.9 to 3.0 | by Devaraju Boddu, https://medium.com/railsfactory/the-evolution-of-keyword-arguments-in-ruby-from-1-9-to-3-0-8bb4ee523a59 31\. Class: OpenStruct (Ruby 2.6.1) \- Ruby-Doc.org, https://ruby-doc.org/stdlib-2.6.1/libdoc/ostruct/rdoc/OpenStruct.html 32\. How do I print out the contents of an object in Rails for easy debugging? \- Stack Overflow, https://stackoverflow.com/questions/4829909/how-do-i-print-out-the-contents-of-an-object-in-rails-for-easy-debugging 33\. Inspecting Ruby's inspect method \- Thoughtbot, https://thoughtbot.com/blog/ruby-inspect-tutorial 34\. Feature \#21389: Simplify Set\#inspect output \- Ruby Issue Tracking System, https://bugs.ruby-lang.org/issues/21389 35\. Class: Time (Ruby 3.0.0), https://ruby-doc.org/core-3.0.0/Time.html 36\. Class: Time (Ruby 2.6), https://ruby-doc.org/core-2.6/Time.html 37\. Class: Range (Ruby 3.1.1), https://ruby-doc.org/core-3.1.1/Range.html 38\. Intro to Peg.js \- Nathan Pointer, https://nathanpointer.com/blog/introToPeg 39\. A Peggy.js Tutorial \- Strumenta \- Federico Tomassetti, https://tomassetti.me/a-peggy-js-tutorial/ 40\. peggyjs/peggy \- Parser generator for JavaScript \- GitHub, https://github.com/peggyjs/peggy 41\. Peggy – Parser Generator for JavaScript, https://peggyjs.org/